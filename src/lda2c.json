{
    "rules": [
        {  "name":"egalité",
            "pattern": "=",
            "replace": "=="
        },
        {  "name":"Et",
            "pattern": "et",
            "replace": "&&"
        },
        {  "name":"Ou",
            "pattern": "\\s+ou\\s+",
            "replace": "||"
        },
        {  "name":"MOD",
            "pattern": "MOD(\\s*\\d+)",
            "replace": "%$1"
        },
        {  "name":"DIV",
            "pattern": "DIV(\\s*\\d+)",
            "replace": "/$1"
        },
        {  "name":"entier",
            "pattern": "entier(\\s*)",
            "replace": "int$1"
        },
         {  "name":"affectation",
            "pattern": "(.*)<-(.*)",
            "replace": "$1=$2;"
        },
        {  "name":"declaration",
            "pattern": "(?:var|tableau)(.*):(.*)",
            "replace": "$2 $1;"
        }
        ,
        {  "name":"répéter",
            "pattern": "répéter\\s*([\\s\\S)]*?)(?:jusqu'à ce que|jusqu'à-ce-que)(.*)",
            "replace": "do{$1}while($2);\n"
        }
        ,
        {  "name":"pour",
            "pattern": "pour(.*)de(.*)à(.*)faire([\\s\\S)]*?)fpour",
            "replace": "for($1=$2;$1<=$3;$1++){$4}\n"
        }
        ,
        {  "name":"si-fsi",
            "pattern": "si(.*)alors([\\s\\S]*?)fsi",
            "replace": "if($1){$2}"
        }
        ,
        {  "name":"sinon",
            "pattern": "([^{]*)sinon([^}]*)",
            "replace": "$1}\nelse{$2"
        }
        ,
        {  "name":"lire",
            "pattern": "lire\\W+(\\w*)",
            "replace": "scanf(\"%d\",&$1);"
        }
        ,
        {  "name":"écrire",
            "pattern": "écrire\\s*(.*)",
            "replace": "printf($1);"
        }
    ]
}